all apis
url=http://localhost:3000
1- url/api/user/getusers
2-url/auth/signup
3--url/auth/signout
4--url/api/travel-story/getall

// npm i dotenv mongooes 



Q1-when 400 and when 404 
Ans-  400- when wrong data or missing data 
404- when route wrong 

Q2- why we use jwt.sign()
ans->=  jwt.sign() creates a secure authentication token by embedding the userâ€™s ID inside a signed payload using a secret key, allowing the server to verify the user on future requests without re-authentication.

Q3-What is the difference?

find() â†’ returns everything (unsafe for private data)

find({ userId }) â†’ returns only logged-in userâ€™s data (secure)


Q4- what is ESM model 

Interview-Ready Explanation

ESM (ECMAScript Modules) is JavaScriptâ€™s official module system where imports are statically analyzed and executed before runtime code. This improves performance and predictability but requires environment variables to be loaded before module imports.


simple-- it run all the important file before dotenv




Q5-ğŸ”¹ How to Know You Are Using ESM
A- we are using in pakage.json {
  "type": "module"
}





Q6-why we use reudx 
A- 1ï¸âƒ£ The Core Problem Without Redux

In a React application without Redux:

Login state is stored in component state (useState)

After refresh â†’ user gets logged out

Passing auth data via props â†’ prop drilling

Multiple components (Navbar, Profile, Dashboard) need auth info â†’ hard to sync

Example issues:

Navbar does not know user is logged in

Protected routes become complex

State duplication across components

2ï¸âƒ£ What Redux Solves for Login & Signup

Redux provides:
âœ” Single source of truth
âœ” Global auth state
âœ” Predictable state updates
âœ” Easy access from any component




Redux helps manage login and signup by maintaining a centralized authentication state that is accessible across the application, ensuring consistent UI updates, secure route protection, and clean separation of logic.â€




























